#pragma once

#include <sys/socket.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/net_tstamp.h>
#include <linux/in.h>
#include <netinet/tcp.h>
#include <net/if.h>
#include <netdb.h>
#include <ifaddrs.h>
#include <fcntl.h>
#include <cerrno>
#include <string_view>
#include <string>
#include <filesystem>

inline auto interface_exists(const std::string& interface) -> bool
{
    return std::filesystem::exists("/sys/class/net" + interface);
}

inline auto get_interface_ip(std::string_view interface) noexcept -> std::string
{
    char buffer[NI_MAXHOST] = {'\0'};
    ifaddrs* ifaddr = nullptr;
    
    if (getifaddrs(&ifaddr) == -1) {
        return std::string{};
    }
    
    ifaddrs* ifa = ifaddr;
    while (ifa) {
        if (ifa->ifa_addr && interface == ifa->ifa_name && ifa->ifa_addr->sa_family == AF_INET) {
            if (getnameinfo(ifa->ifa_addr, sizeof(sockaddr_in), buffer, sizeof(buffer), nullptr, 0, NI_NUMERICHOST) == 0) {
                break;
            }
        }
        ifa = ifa->ifa_next;
    }

    freeifaddrs(ifaddr);
    return std::string{buffer};
}

inline auto set_non_blocking(int32_t fd) noexcept -> int32_t
{
    const auto flags = fcntl(fd, F_GETFL, 0); // this returns the flags associated with fd currently

    if (flags & O_NONBLOCK) 
        return 0;
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK))
        return -1;

    return 0;
}

inline auto disable_nagle(int32_t fd) noexcept -> int32_t
{
    int32_t flag = 1;

    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag)))
        return -1;

    return 0;
}

enum class TimestampType
{
    RX_SOFTWARE, // timestamp when device driver hands packet to kernel receive stack
    RX_HARDWARE, // timestamp generated by NIC when packet is received
    RX_SOFTWARE_AND_HARDWARE
};

// use when not using PACKET_MMAP (TPACKET_Vx includes timestamps automatically)
inline auto set_timestamp(int32_t fd, TimestampType type) noexcept -> int32_t
{
    int flags;
    
    if (type == TimestampType::RX_SOFTWARE)
        flags = SOF_TIMESTAMPING_RX_SOFTWARE;
    else if (type == TimestampType::RX_SOFTWARE)
        flags = SOF_TIMESTAMPING_RX_SOFTWARE;
    else if (type == TimestampType::RX_SOFTWARE_AND_HARDWARE)
        flags = SOF_TIMESTAMPING_RX_SOFTWARE | SOF_TIMESTAMPING_RX_HARDWARE;

    if (setsockopt(fd, SOL_PACKET, SO_TIMESTAMP, &flags, sizeof(flags)))
        return -1;

    return 0;
}

// inline auto set_hardware_timestamp(int32_t fd) noexcept -> int32_t

inline auto would_block() noexcept -> bool
{
    return (errno == EWOULDBLOCK || errno == EINPROGRESS);
}

inline auto set_packet_capture_version(int32_t fd) -> int32_t
{
    int version = TPACKET_V3;

    if (setsockopt(fd, SOL_PACKET, PACKET_VERSION, &version, sizeof(version)))
        return -1;

    return 0;
}

inline auto set_socket_rx_buffer_size(int32_t fd, int32_t size) -> int32_t
{
    int32_t buf_size = size;

    if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &buf_size, sizeof(buf_size)))
        return -1;

    return 0;
}

inline auto bind_to_interface(int32_t fd, std::string_view interface) -> int32_t
{
    sockaddr_ll addr{};
    addr.sll_family = AF_PACKET,
    addr.sll_ifindex = if_nametoindex(interface.data());
    addr.sll_protocol = htons(ETH_P_ALL);

    if (bind(fd, reinterpret_cast<const sockaddr*>(&addr), sizeof(addr)))
        return -1;

    return 0;
}