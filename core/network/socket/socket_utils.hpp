#pragma once

#include <sys/socket.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/net_tstamp.h>
#include <netinet/tcp.h>
#include <net/if.h>
#include <netdb.h>
#include <ifaddrs.h>
#include <fcntl.h>
#include <unistd.h>
#include <cerrno>
#include <string_view>
#include <string>
#include <filesystem>

inline auto interface_exists(const std::string& interface) -> bool
{
    return std::filesystem::exists("/sys/class/net/" + interface);
}

inline auto get_interface_ip(std::string_view interface) noexcept -> std::string
{
    char buffer[NI_MAXHOST] = {'\0'};
    ifaddrs* ifaddr{ nullptr }; 
    
    if (getifaddrs(&ifaddr) == -1) {
        return std::string{};
    }
    
    ifaddrs* ifa = ifaddr;
    while (ifa) {
        if (ifa->ifa_addr && interface == ifa->ifa_name && ifa->ifa_addr->sa_family == AF_INET) {
            if (getnameinfo(ifa->ifa_addr, sizeof(sockaddr_in), buffer, sizeof(buffer), nullptr, 0, NI_NUMERICHOST) == 0) {
                break;
            }
        }
        ifa = ifa->ifa_next;
    }

    freeifaddrs(ifaddr);
    return std::string{ buffer };
}

inline auto set_non_blocking(int32_t fd) noexcept -> int32_t
{
    const auto flags = fcntl(fd, F_GETFL, 0); // this returns the flags associated with fd currently

    if (flags & O_NONBLOCK) 
        return 0;
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK))
        return -1;

    return 0;
}

inline auto disable_nagle(int32_t fd) noexcept -> int32_t
{
    int32_t flag = 1;

    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag)))
        return -1;

    return 0;
}

enum class TimestampType
{
    RX_SOFTWARE, // timestamp when device driver hands packet to kernel receive stack
    RX_HARDWARE, // timestamp generated by NIC when packet is received
    RX_SOFTWARE_AND_HARDWARE
};

// use when not using PACKET_MMAP (TPACKET_Vx includes timestamps automatically)
inline auto set_timestamp(int32_t fd, TimestampType type) noexcept -> int32_t
{
    int flags;
    
    if (type == TimestampType::RX_SOFTWARE)
        flags = SOF_TIMESTAMPING_RX_SOFTWARE;
    else if (type == TimestampType::RX_HARDWARE)
        flags = SOF_TIMESTAMPING_RX_HARDWARE;
    else
        flags = SOF_TIMESTAMPING_RX_SOFTWARE | SOF_TIMESTAMPING_RX_HARDWARE;

    if (setsockopt(fd, SOL_PACKET, SO_TIMESTAMPING, &flags, sizeof(flags)))
        return -1;

    return 0;
}

inline auto timestamp_str(const TimestampType& tstamp_type) -> std::string
{
    if (tstamp_type == TimestampType::RX_SOFTWARE)
        return "software";
    else if (tstamp_type == TimestampType::RX_HARDWARE)
        return "hardware";
    else
        return "software & hardware";
}

inline auto would_block() noexcept -> bool
{
    return (errno == EWOULDBLOCK || errno == EINPROGRESS);
}

inline auto set_socket_rx_buffer_size(int32_t fd, int32_t size) -> int32_t
{
    int32_t buf_size = size;

    if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &buf_size, sizeof(buf_size)))
        return -1;

    return 0;
}

// use with select() and poll()
inline auto set_busy_poll(int32_t fd, int32_t busy_poll_us) -> int32_t
{
    int32_t time = busy_poll_us;

    if (setsockopt(fd, SOL_SOCKET, SO_BUSY_POLL, &time, sizeof(time)))
        return -1;

    return 0;
}

// binding raw socket to interface
inline auto bind_to_interface(int32_t fd, std::string_view interface) -> int32_t
{
    sockaddr_ll addr{};
    addr.sll_family = AF_PACKET,
    addr.sll_ifindex = static_cast<int>(if_nametoindex(interface.data()));
    addr.sll_protocol = htons(ETH_P_ALL);

    if (bind(fd, reinterpret_cast<const sockaddr*>(&addr), sizeof(addr)))
        return -1;

    return 0;
}