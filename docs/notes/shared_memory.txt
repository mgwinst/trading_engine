*** SHARED MEMORY ***

if you don't need sockets, no need to pay for their complexity

"as fast as it gets"

kernel isn't involved in any operations (only when you map it)

multi-processes requires it - which is good for minimizing operational risk




what works well in shared memory?

    contigous blocks of memory
    
    one writer, one or multiple readers (multiple writers is slow!!!)

    

shm_open, mmap, nunmap, shm_unlink, ftruncate, flock...

struct ProtocolHeader {
    std::array<char, PROTOCOL_NAME_MAX_LENGTH> protocol_name;
    uint64_t magic_number;
    uint64_t buffer_size;
    uint64_t major_version;
    uint64_t minor_version;
    std::array<uint32_t, MAX_NUM_QUEUES> queue_size_bytes;
    uint8_t reserved[...]; // space for future protocol changes
} __attribute__((aligned));
